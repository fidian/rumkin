<!DOCTYPE html><html lang=en class="H(100%) Ovy(h)"><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><title>Developer Information</title><link rel=stylesheet href=../../../css/reset.css?1662579161655><link rel=stylesheet href=../../../css/atomic.css?1662579161655><link rel=stylesheet href=../../../css/fonts.css?1662579161655><link rel=stylesheet href=../../../css/site.css?1662579161655><link rel=apple-touch-icon sizes=180x180 href=../../../img/favicon/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../../img/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../../img/favicon/favicon-16x16.png><link rel=manifest href=../../../img/favicon/manifest.json><link rel=mask-icon href=../../../img/favicon/safari-pinned-tab.svg color=#5bbad5><link rel="shortcut icon" href=../../../img/favicon/favicon.ico><meta name=msapplication-config content=../../../img/favicon/browserconfig.xml><meta name=theme-color content=#ffffff><link rel=license href=../../../license><script async src="https://www.googletagmanager.com/gtag/js?id=G-H1S197ZSNH"></script><script>window.dataLayer = window.dataLayer || [];
function gtag() { dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'G-H1S197ZSNH');</script></head><body class="H(100%) Ovx(h) Bgc(pageBorderBackground) Bgc(t)--p"><div class="Maw(1002px) H(100%) W(100%) D(f) Fxd(c) Maw(100%)--p Mx(a) Mx(0)--p"><nav class="Bgc(barBackground) Bgc(t)--p Pos(a) Pos(s)--p T(0) Start(0) End(0) Bdbw(1px) Bdc(barBorder) H(50px) C(barText) C(black)--p Px(10px) Z(1)"><div class="W(100%) D(f) H(100%) Jc(sb) Ai(c) Ov(h)"><div class="D(f) Whs(nw) Ai(c) Fxs(1) Ov(h) Pend(12px)"><a class="C(barText) C(black)--p Fz(1.4em) Fw(b) Tov(e) Ov(h) Fxs(1) Td(n)--p Tov(e) D(b)" href=../../../ >Rumkin.com </a><span class="Px(0.3em) Fxs(0)">&gt;</span> <a class="C(barText) C(black)--p Fz(1.4em) Fw(b) Tov(e) Ov(h) Fxs(1) Td(n)--p Tov(e) D(b)" href=../../ >Software Projects </a><span class="Px(0.3em) Fxs(0)">&gt;</span> <a class="C(barText) C(black)--p Fz(1.4em) Fw(b) Tov(e) Ov(h) Fxs(0) Td(n)--p Tov(e) D(b)" href=../ >D&amp;D Helper</a></div></div></nav><div class="Bgc(pageBackground) Bgc(t)--p Fxg(1)"><div class="Mt(50px) Mt(0)--p C(textColorNormal) P(10px)"><div class="Mx(a) W(100%) Maw(contentWidthMax) Maw(100%)--p D(f) Px(10px) Pstart(0)"><main class="D(tbc) Va(t) W(100%)"><header><h1>Developer Information</h1></header><div class=contents><p>If you do not write Palm programs, you might want to head over to the <a href=../ >main D&amp;D Helper page</a> now. This information gets quite technical.</p><h2 id=database-format-overview>Database Format Overview</h2><p>D&amp;D helper uses different types of databases to generate words, riddles, names, and more. To see what a particular type of database something is, just refer to this list:</p><h3 id=pick>Pick</h3><p>Instead of &quot;generating&quot; something, this file contains a really big list of words, names, or whatever. It then just picks one from the list.</p><p><em>Advantage:</em> The results are really nice. They are actual words/names instead of ones that were assembled. This also works for other things, like random riddles.</p><p><em>Disadvantage:</em> The database is larger. Usually much larger than the Gen or Small types. It also has a very finite number of names that can be generated. Gen and Small can generate a lot more using a smaller database.</p><h3 id=gen>Gen</h3><p>Using a letter pair algorithm, this will assemble a word for you. It also knows what letters should be added onto the word while it is building it. For example, in English, the letter &#39;q&#39; is almost always followed by &#39;u&#39;. Gen keeps track of that information.</p><p><em>Advantage:</em> Words and names that are generated in this fashion look like they belong to the language.</p><p><em>Disadvantage:</em> Even though it is usually smaller than Pick, the database can still be larger than Small.</p><h3 id=small>Small</h3><p>This is the same as Gen, except it doesn&#39;t keep track of the likelihood that a specific letter follows the first one. It just keeps track of whether it happened at all.</p><p>Small can also produce wilder results because it has less restrictions.</p><p><em>Advantage:</em> The database is smaller than Gen.</p><p><em>Disadvantage:</em> The words are sometimes not able to be pronounced, don&#39;t look like they belong to the intended language, and frequently give really odd results.</p><p><em>Special Notes:</em> This database format usually produces very poor results and will only be used if I can not get enough data to use a Gen style database.</p><h3 id=psr><strong>PSR</strong></h3><p>This takes a tree of rules and expands each branch in order to come up with the result. If written properly, this can make extremely realistic names without the size of Gen or Small. It can create sentences, paragraphs, plots, and much more without the size of Pick.</p><p><em>Advantage:</em> The database is usually significantly smaller than an equivalent Small or Pick database.</p><p><em>Disadvantage:</em> It takes time to create the complicated rules, which must be created by hand.</p><h2 id=psr-format>PSR Format</h2><p>This is what I start with when making PSR database entries. This is the most flexible database format that D&amp;D Helper supports. Briefly, it expands a rule into text and other rules.</p><p>For example, let&#39;s try to make a database say &quot;Jack is going to the store.&quot; All examples are real and do work in my parser. The files are all simple text files. The source file to generate the sentence is quite simple:</p><pre><code>* MAIN
Jack is going to the store.
</code></pre><p>The first rule in the file is considered the starting rule. So, we start with <code>[MAIN]</code> and we pick a random rule. Since there is only one, we pick that one. Let&#39;s make this a little more complex by changing the name and the destination.</p><pre><code>* MAIN
[NAME] is going to the [PLACE].

* NAME
Timothy
Jack
Greg

* PLACE
library
store
shed
</code></pre><p>With the above rules, we can get &quot;Timothy is going to the shed.&quot;, &quot;Jack is going to the library.&quot;, &quot;Greg is going to the shed.&quot; and others. In fact, by having 3 names and 3 destinations, we can get a total of 9 different sentences.</p><p>Let&#39;s make this a bit more interesting and add more description.</p><pre><code>* MAIN
[NAME] is [JOINER] the [PLACE].
At the [PLACE], you will find [NAME].

* NAME
Timothy
Jack
Greg
Steve

* PLACE
library
store
shed

* JOINER
[WALK] [TO_FROM]
going to
coming from

* WALK
running
walking
skipping
hopping
hobbling
crawling

* TO_FROM
to
from
towards
away from
nearby
</code></pre><p>With this lengthy example, you can get a bunch of different possibilities. &quot;Jack is coming from the shed.&quot; &quot;Timothy is crawling nearby the library.&quot; &quot;Steve is walking away from the store.&quot; You can see a bunch of possibilities.</p><p>By adding another five names or other places, you get the possibility to create many other phrases. By adding more variances, you can get more flavor in your statements.</p><p>With the above example, you will notice that the <code>JOINER</code> only expands to three possible rules. The first rule, &quot;<code>[WALK] [TO_FROM]</code>&quot; can expand to many possibilities, but it only has a 1/3 chance of being picked if <code>JOINER</code> is used. To make the output look better, we should have the &quot;<code>[WALK] [TO_FROM]</code>&quot; rule get used more often.</p><pre><code>* JOINER
10:[WALK] [TO_FROM]
1:going to
1:coming from
</code></pre><p>With a <code>JOINER</code> section like this, we give preference to the first rule. Essentially, we add the numbers on all of the rules. Then, we pick a random number, then check to see which rule gets it. 10 + 1 + 1 = 12. Picking a random number, 4, means that we use the first rule. If I pick 11 or 12, we use the boring &quot;going to&quot; or &quot;coming from&quot; rules. Essentially, the first rule is 10 times more likely to get picked than either of the &quot;average&quot; rules.</p><pre><code># This is a completely different example.
# Do not just add this to the above PSR rules
#
# Also, any line starting with a # is considered
# a comment and will be ignored.

* NEW_EXAMPLE
Pick up [OBJECT].  [^OBJECT] is over there.

* OBJECT
the sword
an apple
a kitten
</code></pre><p>This example illustrates how you can capitalize the first letter in an expanded rule. The first rule picks two objects (they may be different or the same) and the second object has its first letter capitalized. &quot;Pick up the sword. A kitten is over there.&quot; &quot;Pick up an apple. An apple is over there.&quot; &quot;Pick up a kitten. An apple is over there.&quot; Additionally, it shows how you can add comments to your PSR files.</p><p>The file format also supports long lines -- just use something like this:</p><pre><code>This is one really big line.  I continue it to \
the next line by having a single backslash at \
the end.
</code></pre><p>Lastly, if you have <code>[[]</code>, <code>[]]</code>, <code>[*]</code>, or <code>[#]</code> in your rules, it will convert that into just the <code>[</code>, <code>]</code>, <code>*</code>, or <code>#</code> character, respectively. Newlines can be added by using <code>\n</code>.</p><h2 id=database-format>Database Format</h2><p>Below is the format for the general database. Records are numbered sequentially, starting at 0. The database has a &quot;header&quot; record (#0), then is followed by different sections that contain the data.</p><ul><li>Record 0: Database header<ul><li>Version [2 bytes]: Version number of database. Currently 1. Version 0 was depreciated.</li><li>Flags [2 bytes]: Flags for the database.<ul><li>0x0001 : Generate multiple entries (good for word generators)</li></ul></li><li>Section Record Counts [2 bytes per section]: Number of records for each section. Minimum of 1.</li></ul></li><li>Records 1-n: Sections (one or more of the following)<ul><li>Random Entry</li><li>Letter Pairing</li><li>Phrase-Structure Rule Grammar</li></ul></li></ul><h2 id=random-entry-section>Random Entry Section</h2><p>This type of section is a &quot;pick one of the following&quot; type of list. Good for lists of riddles, random situations, etc.</p><ul><li>First Record: Header<ul><li>Type [2 bytes]: 0</li><li>Flags [2 bytes]:<ul><li>0x0001 : Use random chances (see Chances below)</li></ul></li><li>Items [2 bytes]: Number of items in this section. This shouldn&#39;t match the number of records unless you only put one entry in each record.</li></ul></li><li>All the rest in the section: Data records<ul><li>Number of entries in this record [2 bytes]: Multiple entries can be combined into a single record, saving space and making the database much faster when transferring to the Palm. This works better with smaller data, such as wordlists, but doesn&#39;t really lose anything with larger records.<ul><li>Chance and Offset Array [2 or 4 bytes per entry]:</li><li>Chance [2 bytes]: The chance for this entry. If chances are not used, these two bytes are omitted from the record. Entries are sorted in ascending chance order. (see Chances below)</li><li>Offset [2 bytes]: The offset from the beginning of the record where this entry starts. The entry must be terminated with a NULL.</li></ul></li><li>Entries: Each entry is a null-terminated string. This contains the riddle, situation, word, or whatever data the entry contains. Max size is unknown, but is probably limited by the OS to whatever you can fit in a single record, which is a little under 64k.</li></ul></li></ul><h2 id=letter-pairs-section>Letter Pairs Section</h2><p>One method of building words is to analyze a list of words from a language and figuring out what two letters start words. Then you see what letters possibly follow those two letters and add the third letter. You repeat until you end the word by randomly picking two letters at the end of the word or until a maximum word length is reached.</p><p>It is strongly suggested that you use random chances with this method of word creation. One good example of why is in the English language, the letter Q is almost always followed by U. So, let&#39;s assume that our rules have Q always followed by U. With chances enabled, you&#39;ll see the letter U after every Q unless the word is just too long and had to be stopped. Without chances in the database, the letter U has a 50% chance of showing up. If U is not picked, the word will be ended. This is not exactly what people would like. However, adding chance data increases the database size a lot (over doubles the size), but produces much better results.</p><ul><li>First Record: Header<ul><li>Type [2 bytes]: 1</li><li>Flags [2 bytes]:<ul><li>0x0001 : Use random chances (see Chances below)</li></ul></li><li>Maximum Length: The maximum length of the word. <em>Note: I&#39;d like to have the length taper instead of just snipping it right now.</em></li><li>Starting Pairs: (one or more of these)<ul><li>Chance [2 bytes]: The chance that this letter pair is used. If not using random chances, these two bytes are omitted from the record. (see Chances below)</li><li>Starting pair [2 bytes]: Two letters that words could start with.</li></ul></li></ul></li><li>All the rest in the section: Data records<ul><li>Starting Letter [1 byte]: The first letter of the pair.</li><li>Entries [1 byte]: Number of entries of letters that can follow the starting letter.</li><li>Second Letter Definition: (one of these per Entries)<ul><li>Second letter [1 byte]: The second letter of the pair</li><li>Third letter options [1 byte]: Number of potential third letters that follow the letter pair.</li></ul></li><li>Third Letter Definition: (one of these per Third letter options per Entries):<ul><li>Chance [2 bytes]: The chance for this ending. If chances are not used, these two bytes are omitted from the record. If chances are used and the is no chance high enough, the word is considered finished (just like adding 0xFFFF for the chance and 0x00 for the character, but it saves 3 bytes). (see Chances below)</li><li>Next Letter [1 byte]: A letter that could follow the letter pairs. If not using chances, you should use 0x00 to signify that the next &quot;letter&quot; is actually the end of the word.</li></ul></li></ul></li></ul><h2 id=phrase-structure-rule-grammar-section>Phrase-Structure Rule Grammar Section</h2><p>Based on phrase-structure rules, this section has the potential to create words, sentences, phrases, spell names, and darn near everything else and can be a lot smaller than the letter pairing section or the random entry section.</p><p>This is based on trees, where one rule can expand into multiple rules. Search for <a href="http://www.google.com/search?q=%22phrase+structure+rules%22+examples">phrase structure rules examples</a> on Google.</p><p>If you are trying to create a database from scratch or with an application (not using the format illustrated here and not using the <a href=../download/ >PHP class</a>, then you will need to get into these gory details. Sorry, but it is hard to describe this format without some really bad examples.</p><p>Imagine that W is a rule that is define to generate a word, such as &quot;desk&quot; or &quot;book.&quot; Now, let&#39;s say that we want to generate a compound word with rule C. The rule C would expand to WW, which means to place two words together. This could generate useful words like homework, bookend, and freemason. Unfortunately, it could just as easily generate diskdisk, bubbleslime, and phonetube. It all depends on how you make the rules.</p><p>Let&#39;s say that we want to generate last names. Rule L (for Last name) could potentially expand to WW, just like how C expanded to WW. We would want the first letter capitalized. Also, let&#39;s refer to rule W as the 9th rule in the database... The record would contain the following sequence of bytes as its &quot;expanded rule&quot; (in hex) 01 03 09 01 01 09 00 (&lt;-- null terminated). Confusing? Probably.</p><p>The main rule that is always expanded is the first record (#1).</p><ul><li>First Record: Header<ul><li>Type [2 bytes]: 2</li><li>Flags [2 bytes]: (none defined yet)</li></ul></li><li>All the rest in the section: Data records<ul><li>Flags [2 bytes]:<ul><li>0x0001 : Use random chances for this rule (see Chances below)</li></ul></li><li>Items [2 bytes]: Number of possible rules to expand to</li><li>Expanded Rules: (one or more of the following)<ul><li>Chance [2 bytes]: The chance for this rule. If chances are not used, these two bytes are omitted from the record. (see Chances below)</li><li>Expanded rule: Null-terminated string of data. Command characters may be embedded in the text. Please see Command Codes.</li></ul></li></ul></li></ul><h2 id=chances>Chances</h2><p>For entries with chances, you wish to assign higher and lower chances to particular things. One example is if you are generating a word and you have a Q. You would most likely want a U after it and rarely want the word to stop with just the Q at the end.</p><p>A random number is generated (unsigned int, from 0x0000 to 0xFFFF) and all of the records are scanned with the following algorithm. The first rule or option that is available should have the lowest chance number, and the last one should have the highest (otherwise you&#39;ll always get the first one).</p><ul><li>Is this entry&#39;s chance number &gt;= my random chance number?<ul><li>Yes: Use this entry.</li><li>No: Continue on. If there is nothing else possible, end word/phrase generation.</li></ul></li></ul><p>(For speed purposes, I use a binary search, but the above algorithm does the exact same job.)</p><h2 id=command-codes>Command Codes</h2><p>These strings can be embedded into some types (see above) of records. They tell the program to seek data from elsewhere or to expand to further rules.</p><p>If you are a programmer, you&#39;ll notice that indexes start with 1 instead of 0. This is because the end of string code is a null, and I want to be able to easily count the number of records by merely counting the nulls.</p><ul><li>Command char [1 byte]<ul><li>0x01 - Data contains a single byte, which is a number of a rule to expand to in the current section. Rules are numbered starting at 1 for the first rule after the header record.</li><li>0x02 - Data contains a single byte, which is a number of a section to expand to. Sections are numbered starting at 1 for the first section in the file.</li><li>0x03 through 0x06 - Reserved.</li><li>0x07 - There is a flags byte, but no data bytes. Don&#39;t use this in your rules. It is used internally only to help carry the flags through the transformations.</li><li>0x08 - There is no flags byte. The next character (non-null) is used literally. This is only if you absolutely need to add a 0x01 - 0x08 character in your rules.</li></ul></li><li>Flags [1 byte]:<ul><li>0x01 - Must be set.</li><li>0x02 - Capitalize first letter of generated data</li></ul></li><li>Data [varies]: Defined by the command character. Currently just one byte or none at all.</li></ul></div></main></div></div></div><footer class="Bgc(barBackground) Bgc(t)--p Bdtw(1px) Bdc(barBorder) C(barText) C(black)--p P(10px) D(f) Fxd(c)--p Jc(sb)"><div class=Fz(0.8em)>&copy; Copyright 2022 Tyler Akins &lt;<a class="Td(n)--p C(barText) C(black)--p" href=mailto:fidian@rumkin.com>fidian@rumkin.com</a>&gt;, last build 2022-09-07T19:32:41.655Z</div><div><a class="D(n)--p Fz(0.8em) C(barText)" href=../../../license/ >License</a> | <a class="D(n)--p Fz(0.8em) C(barText)" href=../../../reference/site/legal/ >Legal</a> <a class="D(n) D(b)--p Td(n) Fz(0.8em)" href=../../../license/ >Site content licensed under a MIT license with a non-advertising clause</a></div></footer></div></body></html>