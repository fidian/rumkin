<p>Fuzzy matching and confidence levels is what this exercise is all about. It is tough to match two strings and say that they are quite similar, but not exact. There are a few ways you can achieve this goal.</p><h2 id=levenshtein-distance>Levenshtein Distance</h2><p>This calculates the minimum number of insertions, deletions, and substitutions necessary to convert one string into another. A low distance between two strings means that the strings are more similar. The best site I have found is <a href=levenshtein/ >Levenshtein Distance, in Three Flavors</a>, which I mirrored locally because the original site went down.</p><p>I have modified their algorithm and created <a href=levenshtein.c.txt>C</a>, <a href=levenshtein.prg.txt>FoxPro</a> and <a href=levenshtein.js.txt>JavaScript</a> versions. My methods do not use a huge matrix and instead merely use a one-dimensional array that&#39;s the same length as one of the strings. They also keep the values in the array incremented by 1 so that the comparisons in the loop do not need to perform additional math. The goal was to tweak the loop and try to keep math to a minimum in there.</p><h2 id=gestalt>Gestalt</h2><p>I stumbled across this algorithm in <a href=http://php.net/ >PHP&#39;s</a> documentation about the <a href=http://php.net/manual/en/function.similar-text.php>similar_text()</a> function. The best source for the algorithm that I found was in PHP&#39;s source code for the string functions. Look for the <code>php_similar_str</code>, <code>php_similar_char</code>, and <code>PHP_FUNCTION(similar_text)</code> functions.</p><p>I have created <a href=gestalt.c.txt>C</a> and <a href=gestalt.prg.txt>FoxPro</a> versions of the code. They are both recursive, so be careful with large strings on limited devices. <a href=mailto:ecurtolo@gmail.com>Eduardo Curtolo</a> provided a <a href=gestalt.pas.txt>Pascal</a> version. Someone (sorry, I don&#39;t have this information any longer) contributed a <a href=gestalt.rb.txt>Ruby</a> implementation.</p><h2 id=soundex>SoundEx</h2><p>This algorithm was once used on many U.S. driver&#39;s licenses. Its goal is to group letters that sound alike, then convert the name into a series of numbers that can represent the name. <a href=http://www.creativyst.com/Doc/Articles/SoundEx1/SoundEx1.htm>Understanding Classic Soundex Algorithms</a> provides a very nice description of how SoundEx is used and generated. Taking the concept one step further, you could read <a href=http://www.lanw.com/java-showcase/a-better-phonetic-lookup/ >A Better Phonetic Lookup</a> and get an algorithm that matches really well, which is based on how the language works.</p>